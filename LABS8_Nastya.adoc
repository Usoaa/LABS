= Отчет по лабораторной работе №8
Выполнила студентка группы КЭ-413, Кузнецова А.С.
:imagesdir: Pic
:toc:
:toc-title: Оглавление
:toclevels: 2
:figure-caption: Рисунок
:table-caption: Таблица

include::tituln7.adoc[]

== Понятие АЦП

Аналого-цифровой преобразователь (АЦП) в микроконтроллерах STM32F4, включая модель STM32F411, представляет собой важный периферийный блок, который преобразует аналоговые сигналы в цифровые значения. Этот АЦП использует метод последовательного приближения (Successive Approximation Register, SAR), где входное напряжение пошагово сравнивается с опорным, начиная со старшего бита и заканчивая младшим.

== Основные характеристики АЦП в STM32F411

. Разрядность и точность:
АЦП имеет разрядность 12 бит, что означает, что он может выдавать значения в диапазоне от 0 до 4095.
При опорном напряжении 3.3 В шаг квантования составляет примерно 0.8–1 мВ на бит, в зависимости от режима работы и конфигурации.

. Диапазон измерений:
АЦП способен измерять напряжение в диапазоне от 0 В (VSSA) до VDDA (обычно 3.3 В). Для корректной работы важно, чтобы входное напряжение не выходило за эти пределы.

. Скорость преобразования:
Тактовая частота модуля АЦП может достигать 36 МГц.
Теоретическая максимальная скорость преобразования составляет около 2.4 миллиона выборок в секунду (MSPS) в 12-битном режиме при минимальном времени выборки.

. Мультиканальность:
АЦП поддерживает работу с несколькими каналами — до 19. Из них 16 внешних каналов могут быть использованы для подключения внешних устройств, таких как датчики или потенциометры.
Также доступны три внутренних канала: датчик температуры, опорное напряжение VREFINT и напряжение батареи VBAT.

. Режимы преобразования:
АЦП может работать в различных режимах:
Одиночное преобразование: выполняется одно измерение.
Непрерывное преобразование: измерения проводятся непрерывно.
Сканирование нескольких каналов: АЦП автоматически переключается между заданными каналами.
Дискретный режим: сканирование разбивается на подпоследовательности для более гибкой настройки.

. Триггеры запуска:
Преобразование может быть запущено программно (например, установкой бита SWSTART) или аппаратно (например, сигналом от таймера или внешнего источника).

. Поддержка DMA:
Результаты преобразования могут автоматически передаваться в память через контроллер прямого доступа к памяти (DMA), что освобождает ядро микроконтроллера от необходимости обрабатывать данные вручную.

. Аналоговый сторожевой таймер (Analog Watchdog):
Эта функция позволяет отслеживать выход результатов преобразования за заданные пороги. Если значение выходит за пределы, генерируется событие или прерывание, что полезно для мониторинга критических параметров.

=== Практическое применение АЦП

Благодаря этим характеристикам, АЦП в STM32F411 отлично подходит для широкого спектра задач:

 * Измерение внешних аналоговых сигналов, таких как данные с датчиков или положение потенциометров.
* Мониторинг внутренних параметров микроконтроллера, например, температуры или напряжения питания.
* Реализация систем управления и контроля в реальном времени благодаря высокой скорости преобразования и поддержке DMA.

Этот АЦП сочетает в себе универсальность, точность и производительность, что делает его мощным инструментом для разработки устройств с аналоговыми входами.


== Управляющие регистры

Для настройки и контроля работы АЦП STM32F411 используются специальные регистры. Ниже перечислены основные из них, их назначение и ключевые параметры.

=== ADC_SR (Status Register) — Регистр состояния

* Содержит флаги, отражающие текущее состояние АЦП.

* Ключевые биты:

** EOC (End of Conversion): Флаг завершения преобразования. Это один из самых важных флагов, так как он сообщает программе, что результат готов для чтения из регистра данных 

** OVR (Overrun): Флаг переполнения данных.

** AWD (Analog Watchdog Flag): Флаг срабатывания аналогового сторожа.

Этот регистр позволяет отслеживать состояние АЦП в реальном времени и обрабатывать события, такие как завершение преобразования или выход за допустимые пределы.

=== ADC_CR1 (Control Register 1) — Регистр управления 1

Этот регистр используется для настройки основных параметров работы АЦП, таких как режим сканирования, разрядность и аналоговый сторож.

* Используется для настройки основных параметров АЦП.
* Ключевые биты:
** SCAN: Включение режима сканирования каналов.
** RES[1:0]: Выбор разрядности результата (12, 10, 8 или 6 бит).
** AWDEN: Включение аналогового сторожа.

Этот регистр позволяет настроить базовые параметры АЦП, такие как точность и режим работы, а также включить функцию мониторинга значений через аналоговый сторож.

=== ADC_CR2 (Control Register 2) — Регистр управления 2

Этот регистр управляет запуском преобразования, режимом работы и взаимодействием с другими блоками микроконтроллера (например, DMA). 

* Содержит ключевые параметры для запуска и управления АЦП.
* Ключевые биты:
** ADON: Включение/выключение АЦП и запуск преобразования.
** CONT: Включение непрерывного режима.
** DMA: Разрешение использования DMA для передачи данных.
** ALIGN: Выбор выравнивания результата (левое или правое).

Этот регистр управляет запуском и режимом работы АЦП, а также обеспечивает интеграцию с другими периферийными устройствами, такими как DMA и таймеры.

=== ADC_SMPR1 и ADC_SMPR2 (Sample Time Registers) — Регистры времени выборки

Эти регистры определяют время выборки для каждого канала. Время выборки влияет на точность преобразования, особенно при работе с медленными сигналами.

* Определяют время выборки для каждого канала.
* Ключевые биты:
** SMPx[2:0]: Установка времени выборки для каждого канала (от 3 до 480 тактов АЦП). SMPR1 управляет каналами 10–18, а SMPR2 — каналами 0–9.

Эти регистры позволяют настроить время выборки для каждого канала, что критично для достижения максимальной точности при работе с различными аналоговыми сигналами.

=== ADC_SQRx (Regular Sequence Registers) — Регистры последовательности обычных каналов

Эти регистры определяют порядок и количество каналов, которые будут использоваться в режиме сканирования. 

* Определяют порядок и количество каналов в последовательности преобразования.
* Ключевые биты:
** SQx[4:0]: Номер канала в последовательности.
** L[3:0]: Длина последовательности (количество каналов).

Эти регистры позволяют настроить многоканальное преобразование, что удобно для одновременного измерения нескольких аналоговых сигналов.

=== ADC_DR (Data Register) — Регистр данных

Этот регистр содержит результат последнего преобразования для обычных каналов.

* Содержит результат последнего преобразования для обычных каналов.
* Ключевые биты:
** DATA[11:0]: Цифровое значение результата преобразования (12 бит).

Этот регистр используется для считывания результата преобразования. Именно здесь программа получает цифровое значение, соответствующее входному аналоговому сигналу.

=== ADC_CCR (Common Control Register) — Общий регистр управления

Этот регистр используется для настройки общих параметров нескольких АЦП, таких как использование внутренних датчиков.

* Используется для настройки общих параметров нескольких АЦП.
* Ключевые биты:
** VREFEN: Включение внутреннего опорного напряжения VREFINT.
** TSVREFE: Включение датчика температуры.
** VBATEN: Включение измерения напряжения батареи VBAT.

Этот регистр позволяет использовать встроенные датчики и функции микроконтроллера, что расширяет возможности АЦП.

=== Вывод

Эти регистры обеспечивают полный контроль над работой АЦП STM32F411. Они позволяют:

* Запускать преобразование.
* Настроить точность и время выборки.
* Управлять последовательностью каналов.
* Получать результаты преобразования.
* Использовать дополнительные функции, такие как аналоговый сторож и встроенные датчики.

Благодаря этим возможностям АЦП STM32F411 является универсальным инструментом для работы с аналоговыми сигналами.

== Запуск одиночного преобразования АЦП

В режиме одиночного преобразования АЦП выполняет одно измерение выбранного канала и останавливается, ожидая следующего запуска. Рассмотрим пошагово, как настроить и запустить такой режим:

1.Включение тактирования

Перед началом работы нужно включить тактирование для АЦП и, если требуется, для порта GPIO:

* Установить бит ADC1EN в регистре RCC_APB2ENR, чтобы включить тактирование модуля АЦП.
* Если планируется измерять сигнал с внешнего вывода (например, PA0 для канала 0), включить тактирование соответствующего порта GPIO в регистре RCC_AHB1ENR.

2.Настройка GPIO в аналоговый режим

Если используется внешний канал, перевести нужный вывод GPIO в аналоговый режим:

* В регистре GPIOx_MODER установить биты 11₂ для соответствующего вывода (например, PA0). Это переводит вывод в аналоговый режим, необходимый для работы с АЦП.

3.Конфигурация общего регистра (CCR)

Настроить общий регистр управления ADC_CCR, если это необходимо:

* ADCPRE: Выбрать предделитель тактовой частоты для АЦП (например, 2, 4, 6 или 8).
* TSVREFE: Включить этот бит, если планируется измерять температуру или опорное напряжение.
* VBATE: Включить этот бит, если нужно измерять напряжение батареи (VBAT).

4.Настройка основных параметров АЦП (CR1 и CR2)

Настроить основные параметры работы АЦП в регистрах ADC_CR1 и ADC_CR2:

* В регистре ADC_CR1:
** Установить RES=00 для работы с максимальной разрядностью (12 бит).
** Отключить режим сканирования (SCAN=0), так как работа ведётся только с одним каналом.
** Отключить все прерывания, если работа будет происходить в режиме поллинга (без использования прерываний).

* В регистре ADC_CR2:
** Убедиться, что CONT=0, чтобы АЦП работал в режиме одиночного преобразования.
** Установить ALIGN=0 для правого выравнивания данных (младшие биты результата будут находиться в младших разрядах регистра ADC_DR).
** Оставить ADON=0 до завершения настройки, чтобы АЦП не включился преждевременно.

5.Установка времени выборки (SMPRx)

Настроить время выборки для выбранного канала в регистрах ADC_SMPR1 или ADC_SMPR2:

* Для низкоомных источников сигнала (например, внешних датчиков) достаточно установить время выборки в 15–28 тактов.
* Для высокоомных источников (например, встроенного датчика температуры) рекомендуется увеличить время выборки до 480 тактов.
6. Задание очереди каналов (SQR)

Настроить последовательность каналов в регистрах ADC_SQRx:

* В регистре ADC_SQR3 указать номер канала в поле SQ1 (первый и единственный канал в последовательности).
* В регистре ADC_SQR1 установить L=0, чтобы указать, что будет выполнено только одно преобразование.

7.Включение АЦП

Теперь можно включить АЦП:

* Установить бит ADON в регистре ADC_CR2. После этого дать небольшую задержку (несколько микросекунд), чтобы модуль стабилизировался.

8.Запуск преобразования

Запустить преобразование:

* Установить бит SWSTART в регистре ADC_CR2. Это инициирует процесс оцифровки.

9.Ожидание завершения преобразования

Дождаться завершения преобразования:

* Проверять бит EOC (End of Conversion) в регистре ADC_SR. Когда он установится, это означает, что результат готов.

10.Чтение результата

Считать результат из регистра ADC_DR:

* При правом выравнивании (ALIGN=0) реальные данные находятся в младших 12 битах регистра.
* Считывание результата автоматически сбрасывает флаг EOC.

=== Вывод

Процесс одиночного преобразования включает настройку канала, запуск преобразования и чтение результата. Полученные данные можно использовать, например, для вычисления напряжения или температуры.


== Создание класса для работы с АЦП

Чтобы упростить работу с АЦП и скрыть низкоуровневые детали, часто создают специальный класс на языке C++. Этот класс выполняет следующие задачи:

1.Инициализация АЦП:

* В конструкторе класса настраиваются все необходимые параметры:
** Включается тактирование АЦП и GPIO.
** Конфигурируются регистры CR1, CR2, SMPR и другие.

Таким образом, пользователь может просто создать объект класса, и АЦП будет готов к работе.

2.Методы для чтения данных:

* Класс предоставляет удобные методы, такие как readChannel(uint8_t channel), которые:
** Настройка очереди каналов (SQR).
** Запуск преобразования.
** Ожидание завершения.
** Чтение результата.
* Это позволяет абстрагироваться от работы с регистрами и сосредоточиться на логике программы.

Ниже представлен упрощённый пример класса для работы с АЦП. Этот пример не учитывает все возможные нюансы, но наглядно демонстрирует основную концепцию:

[source,cpp]
----
class ADC_Manager
{
public:
// Конструктор — выполняет базовую настройку АЦП
ADC_Manager()
{
// 1) Включить тактирование АЦП, установив бит RCC_APB2ENR_ADC1EN в регистре RCC->APB2ENR.
// 2) Настроить общий регистр ADC->CCR: выбрать предделитель частоты и при необходимости включить бит TSVREFE для измерения температуры или опорного напряжения.
// 3) Установить параметры в регистрах CR1 и CR2: выбрать одиночный режим, разрядность 12 бит, правое выравнивание данных и другие необходимые настройки.
// 4) Включить АЦП, установив бит ADON в регистре ADC_CR2.
}

// Метод для чтения значения с указанного канала
uint16_t readChannel(uint8_t channel)
{
// 1) Настроить время выборки для выбранного канала, записав соответствующее значение в регистр SMPRx.
// 2) Задать номер канала в регистре SQR: установить L=0 (одно преобразование) и записать номер канала в поле SQ1.
// 3) Запустить преобразование, установив бит SWSTART в регистре ADC_CR2.
// 4) Дождаться завершения преобразования, проверяя установку флага EOC в регистре ADC_SR.
// 5) Считать результат из регистра ADC_DR и вернуть его.
return 0; // В реальном коде здесь будет возвращено значение, считанное из ADC_DR.
}
};
----

Такой класс инкапсулирует:
* Процедуру включения питания АЦП.
* Настройку регистров CR1, CR2, SMPR1/2, SQR и др.
* Запуск и завершение преобразования.

Класс ADC_Manager упрощает работу с АЦП микроконтроллера STM32F411. Он автоматически настраивает АЦП при создании объекта и предоставляет метод readChannel(uint8_t channel) для выполнения одиночных измерений с указанного канала. Пользователь может легко получить цифровое значение аналогового сигнала, не работая напрямую с регистрами.

В основной программе достаточно создать объект класса ADC_Manager adc; и использовать метод adc.readChannel(номер_канала), чтобы получить 12-битное значение. При необходимости результат можно преобразовать в напряжение или другие физические величины. Такой подход упрощает чтение кода и позволяет изменять настройки АЦП (например, время выборки или разрядность) в одном месте — внутри класса.

== Измерение температуры встроенного датчика

В микроконтроллере STM32F411 есть встроенный датчик температуры, подключённый к каналу ADC_IN18. Этот датчик измеряет температуру самого кристалла микроконтроллера (а не окружающей среды) и обычно используется для внутреннего мониторинга.

1.Включение датчика и настройка времени выборки

Прежде чем измерять температуру, нужно выполнить несколько шагов:

* Установить бит TSVREFE в регистре ADC_CCR. Это включает питание датчика температуры и внутреннего опорного напряжения.
* Для канала 18 задать максимальное время выборки — 480 тактов (код 111). Это необходимо, так как датчик имеет высокое выходное сопротивление, и короткое время выборки может привести к неточным результатам.

2.Выбор канала

Настроить последовательность каналов для измерения:

* В регистре ADC_SQR3 указать номер канала (SQ1=18).
* В регистре ADC_SQR1 установить поле L=0, чтобы выполнить одиночное преобразование.

3.Запуск и чтение результата

Теперь можно запустить преобразование:

* Установить бит ADON в регистре ADC_CR2, чтобы включить АЦП.
* Запустить процесс измерения, установив бит SWSTART в том же регистре.
* Дождаться завершения преобразования, проверяя флаг EOC в регистре ADC_SR.
* После завершения считать код результата из регистра ADC_DR.

4.Перевод кода в температуру

Чтобы перевести полученный код в градусы Цельсия, используются заводские калибровочные данные. В документации (Reference Manual и Datasheet) указана формула:

  T = 30°C + ( (Code_measured - TS_CAL1) / (TS_CAL2 - TS_CAL1) ) * (110°C - 30°C) 

Где: 

 TS_CAL1 — заводской калибровочный код при температуре 30°C TS_CAL2 — заводской калибровочный код при температуре 110°C

Адреса значений TS_CAL1 и TS_CAL2 указаны в документации для конкретного чипа. Эти значения хранятся в памяти микроконтроллера и могут быть считаны программно для точного расчёта температуры.

Если калибровочные данные недоступны, можно использовать упрощённую формулу:

Средний наклон характеристики датчика составляет примерно 2.5 мВ/°C .
Опорное напряжение при 25°C равно примерно 0.76 В .

=== Вывод

Измерение температуры кристалла в STM32F411 легко интегрируется в программу, если соблюдать требования к настройке времени выборки и включению питания датчика. Однако важно помнить, что показания отражают температуру самого кристалла, которая может значительно отличаться от температуры окружающей среды, особенно при высокой нагрузке на микроконтроллер.



== Измерение напряжения на переменном резисторе

Измерение аналогового сигнала от потенциометра
Измерение сигнала от потенциометра — это классический пример использования АЦП в микроконтроллере. Потенциометр обычно подключается между питанием (3.3 В) и землёй, а его средний вывод (ползунок) подключается к входу АЦП.

1.Подключение и настройка GPIO

Перед началом работы нужно правильно настроить вывод микроконтроллера:

* Убедиться, что выбранный вывод (например, PA0, который соответствует каналу 0 АЦП) переведён в аналоговый режим. Для этого в регистре GPIOx_MODER установите значение 11₂ для нужного вывода.
* Включить тактирование порта GPIO (например, порта A), установив бит GPIOAEN в регистре RCC_AHB1ENR.

2.Настройка АЦП

Теперь настройте сам АЦП:

1. Включить модуль АЦП, установив бит ADC1EN в регистре RCC_APB2ENR.
2.  Задать основные параметры работы АЦП:
* Разрядность: 12 бит (максимальная точность).
* Режим: одиночное преобразование.
* Выравнивание данных: вправо.

Эти параметры настраиваются в регистрах CR1 и CR2.

3.Установить время выборки в регистре SMPR. Для низкоомного источника, такого как потенциометр (обычно несколько кОм), достаточно задать время выборки 15 или 28 тактов.

4.Указать номер канала в последовательности преобразования:

* В регистре SQR3 записать номер канала (например, SQ1=0 для канала 0).
* В регистре SQR1 установить длину последовательности L=0, чтобы выполнить только одно преобразование.
5.Включить АЦП, установив бит ADON в регистре ADC_CR2.

3. Выполнение преобразования

Чтобы измерить сигнал:

* Запустить преобразование, установив бит SWSTART в регистре ADC_CR2.
* Дождаться завершения преобразования, проверяя флаг EOC в регистре ADC_SR.
* После завершения считать результат из регистра ADC_DR.

4. Перевод результата в напряжение

Полученное 12-битное значение (диапазон 0–4095) соответствует уровню напряжения от 0 до опорного напряжения (обычно 3.3 В). Чтобы перевести код в вольты, можно использовать формулу:

  voltage = (ADC_CODE / 4095.0f) * VREF

Например, при VREF = 3.3 В, если код 2048, то напряжение ≈ 1.65 В (примерно половина диапазона).

=== Вывод

Считывая напряжение с ползунка потенциометра, можно легко определить его текущее положение. Этот же подход используется для работы с другими аналоговыми датчиками, которые выдают сигнал в диапазоне 0–3.3 В. Такой метод позволяет быстро и точно получать данные о состоянии внешних устройств.


== Заключение

В рамках этой работы изучено устройство и применение 12-битного АЦП типа SAR в микроконтроллере STM32F411. Показано, что АЦП способен быстро и точно оцифровывать аналоговые сигналы — от показаний встроенного датчика температуры до напряжения на внешнем потенциометре. Основные аспекты, которые важно учитывать:

* Особенности настройки регистров управления (CR1, CR2), времени выборки (SMPR1/2) и последовательности каналов (SQR).
* Включение тактирования АЦП и перевод нужного вывода GPIO в аналоговый режим.
* Возможность работы с одним или несколькими каналами, а также специальный режим для измерений с внутренним датчиком температуры.
* Необходимость увеличения времени выборки при работе с высокоомными источниками сигнала, такими как встроенный термодатчик.
* Поддержка DMA и прерываний, которая упрощает обработку больших объёмов данных и организацию асинхронной работы.
* Функция аналогового сторожа, позволяющая автоматически реагировать на выход значений за заданные пороги.

Для удобства практической реализации рекомендуется вынести логику управления АЦП в отдельный класс. Это позволяет скрыть сложные детали настройки регистров и предоставить простой интерфейс для чтения данных. Такой подход делает код более понятным, надёжным и удобным для дальнейшего использования.

Таким образом, грамотно настроенный АЦП расширяет возможности микроконтроллера, позволяя эффективно работать с различными аналоговыми сигналами и датчиками. Это обеспечивает гибкость и высокую функциональность встраиваемых систем.

[source,cpp]
----
#include "rccregisters.hpp"    // for RCC
#include "gpioaregisters.hpp"  // for GPIOA
#include "gpiocregisters.hpp"  // for GPIOC
#include <array>
#include <cstdint>
#include "adc1registers.hpp"   // for ADC CR1
#include <iostream>

#include "stkregisters.hpp"    // for SystemTimer
#include "scbregisters.hpp"    // for ISCR register
#include "tim2registers.hpp"

#include "ILed.h"
#include "Led.h"
#include "ledconfig.h"

#include "IMode.h"
#include "allmode.h"
#include "treemode.h"
#include "chessmode.h"
#include "modeconfig.h"
#include "IButton.h"
#include "Button.h"
#include "IModeManager.h"
#include "modeconfig.h"
#include "ModeManager.h"
#include "ButtonExti.h"
#include "ModeManagerConfig.h"
#include "syscfgregisters.hpp"
#include "extiregisters.hpp"
#include "nvicregisters.hpp"   // for NVIC
#include "tim5registers.hpp"   // for TIM5

std::uint32_t SystemCoreClock = 8'000'000U;

extern "C" {
int __low_level_init(void)
{
  RCC::CR::HSION::On::Set();
  // while (RCC::CR::HSIRDY::NotReady::IsSet()) { }
  RCC::CFGR::SW::Hsi::Set();
  // while (!RCC::CFGR::SWS::Hsi::IsSet()) { }

  RCC::APB2ENR::SYSCFGEN::Enable::Set();
  STK::CTRL::CLKSOURCE::CpuClock::Set();
  RCC::APB1ENR::TIM5EN::Enable::Set();

  NVIC::ISER1::Write(1 << 18U);

  const auto TimerDivider = SystemCoreClock / 1'000U;

  TIM5::PSC::Write(TimerDivider);
  TIM5::CR1::URS::Value1::Set();
  TIM5::ARR::Write(500U);
  TIM5::SR::UIF::Set(0);
  TIM5::CNT::Write(0);
  TIM5::DIER::UIE::Value1::Set();
  TIM5::CR1::CEN::Enable::Set();

  return 1;
}
}

bool isInterruptHappened = false;

int main()
{
  // Подаём тактирование на порт A
  RCC::AHB1ENR::GPIOAEN::Enable::Set();
  // Подаём тактирование на порт C
  RCC::AHB1ENR::GPIOCEN::Enable::Set();
  
  // Порт A.5 на вывод
  GPIOA::MODER::MODER5::Output::Set();
  // Порт C.5, C.8, C.9 на вывод
  GPIOC::MODER::MODER5::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();

  // Создаём объект кнопки, привязанной к выводу PC13 (EXTI)
  ButtonExti<GPIOC, 13> button;

  // Создаём объекты светодиодов
  Led<GPIOC, 5> led1;
  Led<GPIOC, 8> led2;
  Led<GPIOC, 9> led3;
  Led<GPIOA, 5> led4;

  // Собираем их в массив
  tLeds leds = { &led1, &led2, &led3, &led4 };

  // Создаём разные режимы (пример демонстрационной логики)
  AllMode allmode(leds);
  ChessMode chessmode(leds);
  TreeMode treemode(leds);

  // Список режимов для диспетчера
  tMode MODES = {
    &allmode,
    &chessmode,
    &treemode
  };

  // Создаём диспетчер режимов
  ModeManager modeManager(MODES);
  modeManager.InitModeManager();

  // Основной цикл
  for(;;)
  {
    if (isInterruptHappened)
    {
      // Обновление состояния режимов
      modeManager.UpdateModeManager();

      // Проверяем нажатие кнопки
      if(button.onClick())
      {
        // Переключаемся на следующий режим
        modeManager.SwitchModeManager();
      }
      isInterruptHappened = false;
    }
  }

  return 1;
}
----