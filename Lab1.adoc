= Лабораторная работа 1
Выполнила студентка группы КЭ-413, Кузнецова А.С.
:imagesdir: Picture
:toc:
:toc-title: Оглавление
:toclevels: 2
:figure-caption: Рисунок
:table-caption: Таблица

== Процесс разработки ПО
Разработка программного обеспечения заключается в создании программных продуктов и различных приложений. Например:операционные системы, веб-сайты, мобильные приложения и офисные программы.

Рассмотрим основные этапы разработки ПО.

. Анализ требований. Этот этап заключается в общении с заказчиком, для того чтобы узнать его потребности и требования к программному продукту. После всех согласований с заказчиком, создается документ с требованиями.
Проектирование ПО. В данном этапе разрабатывается архитектура и дизайн программного продукта. Проектируются структура данных, интерфейсы пользователя, компоненты системы и алгоритмы.
. Программирование. На этом этапе разработчики пишут программу в соответствии с требованиями и дизайном, определенными на предыдущих этапах.
. Тестирование ПО.  На этом этапе программный продукт проходит проверку на качество с помощью различных видов тестирования.
. Системная интеграция.
. Установка ПО. На этом этапе загружают и настраивают программу на компьютере или другом устройстве.
. Сопровождение ПО. Это этап включает в себя различные обновления, исправление ошибок и тех. поддержку.

Разработка программного обеспечения – это сложный процесс, в котором важен порядок, структура и сроки выполнения. Иначе заказчик будет недоволен.

== Компиляция кода, линковка и загрузка

=== Процесс компиляции

Компиляция - это процесс преобразования исходного кода программы, написанного на языке высокого уровня, в машинный код, с которым разобирается компьютер. 

Суть компиляции заключается в том, что компилятор анализирует исходный код, проверяет его синтаксис, выявляет возможные ошибки и преобразует его в машинный код, понятный процессору. Это позволяет создавать сложные программы с помощью простого и понятного кода на языке высокого уровня, отделяя разработчика от низкоуровневых деталей. 

Процесс компиляции состоит из следующих этапов:

. Лексический анализ. Последовательность символов исходного файла преобразуется в последовательность лексем.
. Синтаксический анализ. Последовательность лексем преобразуется в дерево разбора.
. Семантический анализ. Дерево разбора обрабатывается с целью установления его семантики (смысла) — например, привязка идентификаторов к их декларациям, типам, проверка совместимости, определение типов выражений и т. д.
. Оптимизация. Выполняется удаление излишних конструкций и упрощение кода с сохранением его смысла.
. Генерация кода. Из промежуточного представления порождается объектный код.

Результатом компиляции является объектный код.

Объектный код — это программа на языке машинных кодов с частичным сохранением символьной информации, необходимой в процессе сборки.

Этапы компиляции представлены (рисунок <<picture1>>).

.Этапы компиляции
[#picture1]
image::Рисунок1.png[]

=== Компоновка
Компоновка (линковка) – это последний этап процесса получения исполняемого файла, который связывает вместе все объектные файлы проекта.

На этом этапе можно столкнуться с ошибками связывания.
Если, например, функция была объявлена, но не определена, ошибка покажется только на этом этапе.

=== Загрузка

Загрузка переносит программу в оперативную память, это необходимо, потому что работа с данными в оперативной памяти происходит быстрее, чем с диска. Далее начинается выполнение программы.
Загрузка нужна для того, чтобы программа работала быстрее и эффективнее.

== Запуск кода на микроконтроллере

Запуск кода на микроконтроллере позволяет коду управлять такими функциями как, датчики, светодиоды и т.д. Запуск кода производится в несколько этапов. Рассмотрим более подробно каждый из них.

1. Написание программы. 
2. Компиляция. Она преобразует ваш исходный код в машинный код (объектный код).
3. Загрузка кода. После компиляции полученный файл нужно загрузить на микроконтроллер. 
4. Выполнение кода. Микроконтроллер начинает поочередно выполнять команцы из памяти.
5. Отладка и тестирование. При запуске кода могут возникать ошибки, и для этого может понадобиться отладка. Чтобы улучшить код или исправлять ошибки. 

Таким образом, запуск программы на микроконтроллере - это процесс написания кода, его загрузки в память, и последующее выполнение инструкций.

== Что такое стек и для чего он нужен?

Стек (stack) — это способ хранения в памяти компьютера. Он работает так, что последний элемент, добавленный в стек, будет взят из него первым.

Стек вызовов — это структура данных, которая управляет вызовами функций во время выполнения программы.

Для наглядности рассмотрим более подробно на схеме. Рассмотрим пример программы с тремя функциями: первая вызывает вторую, вторая — третью и так далее.

Шаг 1. Компьютер выполняет основную программу и доходит до вызова функции 1. Он прерывает выполнение основной программы, помещает адрес возврата в стек и переходит к выполнению функции 1 (pисунок <<picture2>>).

.Шаг 1
[#picture2]
image::Рисунок2.png[]

Шаг 2. Компьютер выполняет функцию 1 и доходит до вызова функции 2. Он прерывает выполнение функции 1, помещает её адрес возврата в стек и выполняет функцию 2 (pисунок <<picture3>>).

.Шаг 2
[#picture3]
image::Рисунок3.png[]

Шаг 3. Компьютер заканчивает выполнение функции 2, считывает и удаляет с вершины стека адрес возврата функции 1. Затем он переходит к функции 1 и продолжает её выполнение с инструкции, находящейся по адресу возврата (pисунок <<picture4>>).

.Шаг 3
[#picture4]
image::Рисунок4.png[]

Шаг 4. Компьютер заканчивает выполнение функции 1, считывает и удаляет с вершины стека адрес возврата основной программы. Затем он переходит к основной программе и продолжает её выполнение с указанного адреса. Стек полностью очищается до следующего вызова (pисунок <<picture5>>).

.Шаг 4
[#picture5]
image::Рисунок5.png[]

=== Как размер стека влияет на программу?
Чтобы стек не разрастался в памяти, ему задаётся конкретный размер — либо системой, либо самим программистом. Но если вызовов в программе будет слишком много, стек может внезапно переполниться — в этом случае программа аварийно завершит работу и выдаст ошибку о переполнении стека.

== Локальные и глобальны переменные
Локальными называют любые переменные, объявленные внутри функции.
Глобальными называют переменные, объявленные в программе вне функций (в том числе и вне функции main()). Глобальные переменные существуют в течение всего времени работы программы и занимают память независимо от того, используются они или нет.
В замкнутом внутреннем мире мы можем иметь свои переменные, но также иметь доступ к переменным внешнего, глобального мира. А из внешнего мира не видно то, что что происходит во внутреннем (pисунок <<picture6>>).

.Пример глобальных и локальных переменных
[#picture6]
image::Рисунок6.png[]

В начале работы функция выделяет память в стеке для запоминания своих локальных переменных. После возврата из функции стековая память удаляется, уничтожая все хранящиеся в ней переменные, что позволяет:

* обеспечить большее, по сравнению с доступной памятью, суммарное пространство, занимаемое всеми локальными переменными;

* бесконфликтно объявлять одинаковые идентификаторы для локальных переменных, используемых в различных функциях одной программы.

Глобальные переменные необходимы в тех случаях, когда данные нужно сделать доступными для многих функций, а передача параметров из функции в функцию является проблематичной. Однако использование глобальных переменных в силу своей общедоступности часто чревато возникновением ошибок.

Локальным переменным нужно присваивать начальные значения до их использования, так как в момент объявления значения этих переменных не определены. Глобальные переменные автоматически инициализируются нулевыми значениями при их объявлении.

== Как работает компоновщик?

Работа компоновщика состоит из трех частей:

* Во-первых, взять все объектные файлы, сгенерированные компилятором, и объединить их в единую исполняемую программу.
Процесс компоновки пренставлен (pисунок <<picture7>>).

.Рисунок процесс компоновки (линковки)
[#picture7]
image::Рисунок7.png[]

* Во-вторых, помимо возможности связывать объектные файлы, компоновщик (линкер) также может связывать файлы библиотек. Файл библиотеки – это набор предварительно скомпилированного кода, который был «упакован» для повторного использования в других программах.
* В-третьих, компоновщик обеспечивает правильное разрешение всех межфайловых зависимостей. Если компоновщик не может связать ссылку с чем-то с ее определением, вы получите ошибку компоновщика, и процесс линковки будет прерван.

Как только компоновщик завершит линковку всех объектных файлов и библиотек (при условии, что всё идет хорошо), будет получен исполняемый файл, который затем можно будет запустить!

=== Как компоновщик располагает переменнные по адресам?

Рассмотрим, как компоновщик располагает переменные по адресам, в несколько этапов:

. Код и данные. На этом этапе компоновщик соединяет все части программы (код, функции, переменные), которые хранятся в разных файлах.
. Адреса памяти. Каждая программа работает в области памяти, которая делится на адреса. Компоновщик присваивает каждому элементу программы уникальный адрес в этой области памяти. 
. Следит за размерами. Компоновщик смотрит за тем, сколько места занимает каждая переменная. Это нужно во избежание наложения элементов друг на друга. 
. Расставляет элементы. Компоновщик начинает с первого адреса и поочередно выделяет место для каждой переменной и функции.
. Создание таблицы. В итоге компоновщик создает таблицу, в которой записаны адреса всех переменных и функций. Это нужно, чтобы в дальнейшем программа знала, где каждый элемент находится в памяти. 
. Финальный файл. В конце компоновщик создает один исполняемый файл, который содержит всё необходимое для работы программы.

== Секции

Секции — это области в файле объекта или исполняемом файле. В них содержатся различные типы данных или кода. Рассмотрим несколько из них:

* .text — скомпилированный машинный код, сюда помещаются все написанные фукции и алгоритмы 
* .data — глобальные и статические переменные. 
* .rodata — аналог .data для неизменяемых данных. К примеру для строк, которые выводятся на экран.
* .bss — глобальные и статические переменные, которые при старте содержат нулевое значение.


==  Оптимизация, и ее влияние на результат компилятора

Оптимизация — это процесс преобразования фрагмента кода в другой фрагмент, который функционально эквивалентен исходному, с целью улучшения одной или нескольких его характеристик, из которых наиболее важными являются скорость и размер кода. Другие характеристики включают количество потребляемой энергии на выполнения кода и время компиляции.

== Ответы на вопросы

. Дайте определение понятию «Интегрированной среде разработки».
Ответ:
Интегрированная среда разработки – это программное приложение, которое помогает разработчикам писать, проверять, тестировать и запускать код, а также ведут большие проекты.

. Что такое компилятор и чем он отличается от транслятора?     
Ответ:
Компилятор - транслятор, который осуществляет перевод исходной программы в эквивалентную ей объектную программу на языке машинных команд или языке ассемблера.
Транслятор  – программа, которая переводит понятные человеку слова в понятные компьютеру двоичные коды..
Компилятор отличается от транслятора тем, что его результирующая программа всегда должна быть написана на языке машинных кодов или на языке ассемблера. Результирующая программа транслятора, в общем случае, может быть написана на любом языке. Соответственно, всякий компилятор является транслятором, но не наоборот.

. Что такое компоновщик и какие функции он выполняет?  
Ответ:
Компоновщик – предназначен для связывания между собой объектных файлов, порождаемых компилятором, а также файлов библиотек, входящих в состав системы программирования.
Функция компоновщика достаточно проста. Он начинает свою работу с того, что выбирает из первого объектного модуля программную секцию и присваивает ей начальный адрес. Программные секции остальных объектных модулей получают адреса относительно начального адреса в порядке следования. При этом может выполняться также функция выравнивания начальных адресов программных секций. Одновременно с объединением текстов программных секций объединяются секции данных, таблицы идентификаторов и внешних имен.

. Почему важен процесс проектирования ПО какие задачи входят в этот процесс?  
Ответ:
При разработке программного обеспечения начинать следует с проектирования — т.е. с полного планирования того, что непосредственно придётся разрабатывать, в какие сроки, с какими исходными данными и ожидаемым результатом.
Определив требования к программному обеспечению, разработчик получает согласованный четкий план действий, график оплат и сроков, сокращает время разработки и повышает её качество, а также позволяет предусмотреть любые другие нюансы разработки, например, юридические (в частности по передаче авторских прав на программное обеспечение).
Проектируя ПО заранее, разработчик получает возможность:
o	оценить стоимость и время разработки программного продукта,
o	исключить потери времени и денег на ненужные действия, вынужденные доработки, длительное согласование,
o	избежать разногласий и неудовлетворённости клиента и исполнителя.
При подготовке к проектированию решаются организационные вопросы:
o	что клиент может предоставить (ТЗ, макеты, дизайн), насколько достаточны исходники и какие этапы закрывают — таким образом определяется состав работ,
o	бюджет и сроки: на основе имеющихся материалов утверждается примерная стоимость, срок всего проекта, а также срок и точная стоимость ближайшего этапа.

. Дорисуйте процесс разработки ПО, описанный на изображении «Процесс разработки с точки зрения IAR Workbench» с учетом итеративности связей в этом процессе.
Ответ: (-)

. Зачем нужна отладка и в каких случаях она применяется? Для чего применяются точки остановки?  
Ответ:
Отладка – это процесс поиска и исправления ошибок или неполадок в исходном коде какого-либо программного обеспечения. Когда программное обеспечение не работает, как ожидалось, компьютерные программисты изучают код, чтобы выяснить причину появления ошибок.

. Какие еще важные IAR workbench можно добавить в таблицу «Характеристики IAR»?  
Ответ:

В таблице 1 приведены характеристики IAR.
[#Характеристики IAR Embedded Workbench]
.Характеристики IAR Embedded Workbench
[options="header"]
|=====================
|Характеристика|IAR Embedded Workbench
|Языки               |С/C++
|Стандарты языка     |С++ 17 начиная с версии 8.40
|Оптимизация кода    |Да, кроме condition_variable, future, mutex, shared_mutex, thread, поддержка
atomic урезана и реализована только для типов для которых есть аппаратная поддержка atomic
специальными командами в микроконтроллерах
|Контроль размера стека  |Да
|Поддержка RTOS  |Да
|Статический анализатор кода с набором правил |Да - MISRAC++2008, SECURITY,CERT, STDCHECKS
|Динамический анализ кода  |C-RUN
|Сертификация и проверка соответствию стандартам безопасности  |Сертификация на безопасность по стандартам IEC 61508 и ISO 26262 экспертной организацией TUV SUD – SIL3 сертификат
|Поддержка микроконтроллера STM32F411 RE |Полная
|Среда исполнения |clib, dlib
|Память |от tiny до large (и выше)
|Поддержка стандарта MISRA C |Есть
|=====================

== Заключение

В результате данной работы изучила процесс разработки ПО, а также узнала как происходит запуск кода на микроконтроллере. Рассмотрела понятие стека и как он влияет на программу. Стала лучше понимать и разбираться в данной теме.

