= Отчет по лабораторной работе №2
Выполнила студентка группы КЭ-413, Кузнецова А.С.
:imagesdir: Picture2
:toc:
:toc-title: Оглавление
:toclevels: 2
:figure-caption: Рисунок
:table-caption: Таблица

== Типы данных

Типы данных — это классификации данных, которые определяют, какой вид информации они могут хранить, какие операции могут быть выполнены с этими данными и как они будут представлены в памяти. 

Типы данных нельзя смешивать между собой, так как могут возникнуть следующие проблемы:

. Ошибки. Если, например, сложить число и текст, программа может не понять что ей нужно сделать.

. Неправильные результаты. Например, при попытке превратить текст "три" в число, это не сработает.

. Можно запутаться в коде. Когда в коде используются разные типы данных вместе, это может запутать, при чтении кода.

. Производительность: Смешивание типов может замедлять работу программы, так как компьютеру придется делать дополнительные проверки и преобразования.

Далее будут рассмотренны типы данных.

=== Встроенные типы

Встроенные типы (базовые типы). Встроенные типы предопределены стандартом языка, указываются зарезервированными ключевыми словами и характеризуются одним значением. Их не надо определять и их нельзя разложить на более простые составляющие без потери сущности данных. Встроеные типы объектов создают основу для построения более сложных типов.

Не стоит использовать встроенные типы данных, потому что они могут быть ограниченными и не подходить для решения множества задач, а также усложнять понимание кода.

[#Встроенные типы С++]
.Встроенные типы С++
[options="header"]
[cols="2,1,7"]
|=====================
|Тип | Длина |Комментарий
|*bool*| 1| Представляет значения, которые могут быть или *true*, или *false*.
|*char*|1	| Используется для символов ASCII в старых строках в стиле C или в объектах std::string,
которые никогда не будут преобразовываться в Юникод.
|*unsigned char*| 1 |	Аналог байта. В С++17 стандарте появился тип std::byte
|*int*|	4 |Целочисленное значение. Выбор по умолчанию для целых чисел
|*unsigned int*| 4| Беззнаковое целое число
|*float*| 4	|Число с плавающей точкой, поддерживается аппаратно некоторыми микроконтроллерами
|*double*| 8	|Число с плавающей запятой двойной точности. Выбор по умолчанию для значений с плавающей
точкой
|=====================

=== Модификаторы типов данных
[#Встроенные типы С++ модификаторы]
.Встроенные типы С++ модификаторы
[options="header"]
[cols="2,1, 7"]
|=====================
|Тип | Длина |Комментарий
|*short int*|	2|Целочисленное знаковое значение укороченной длины
|*unsigned short int*| 2|	Целочисленное беззнаковое значение укороченной длины
|*long int*|	8|Выбор по умолчанию для целочисленных значений. На платформах на которых int равен по
длине unsigned short int может быть длиннее int
|*unsigned long int*|8	|Целое число двойной длины. На платформах на которых int равен по длине unsigned short int может быть
длиннее int
|*long double*|8	|Число с плавающей точкой двойной точности	с двойной точностью 
|=====================

=== Неявное преобразование типов

Базовые/простые типы неявно можно привести друг к другу. Неявное преобразование происходит, когда компилятор ожидает значение одного типа, но получает значение другого типа.
Таким образом при неявном преобразовании, при выводе результатов расчетов функции теряется точность вычисления.

=== Явное преобразование типов

Вместо неявного преобразования типов, лучше указать компилятору явное преобразование из одного типа в другой. 

Для преобразований из одного типа используют 4 варианта преобразования:

. static_cast;

. const_cast;

. reinterpret_cast;

. dynamic_cast.

static_cast позволяет сделать приведение близких типов (целые, пользовательских типов которые могут создаваться из типов который приводится, и указатель на void* к указателю на любой тип).
Проверка производится на уровне компиляции, так что в случае ошибки сообщение будет получено в момент сборки приложения или библиотеки.

reinterpret_cast преобразует типы, несовместимыми друг с другом, и используется для:

* В свой собственный тип.

* Указателя в интегральный тип.

* Интегрального типа в указатель.

* Указателя одного типа в указатель другого типа.

* Указателя на функцию одного типа в указатель на функцию другого типа.

=== Размеры типов данных

Размеры типов для различных микроконтроллеров могут отличаться, так как они не четко определены.

Поэтому вместо прямых типов типа int, используйте псевдонимы, например:
[horizontal]
* std::uint32_t:: целое беззнаковое длиной 32 бита.
* std::int64_t::  целое знаковое длинной 64 бита.
* std::uint8_t:: целое знаковое длинной 8 бит.

*Псевдоним типа данных* - это специальный вид типа данных, который определяется пользователем при использовании существующих базовых типов данных.

Чтобы было понятнее работать с типом можно вводить их псевдонимы (alias). С помощью
ключевого слова *using*.

== Память

ARM имеет общее адресное пространство для данных и команд.

ARM (Advanced RISC Machines) - система команд и семейство описаний и готовых топологий 32-битных и 64-битных микропроцессорных/микроконтроллерных ядер, разрабатываемых компанией ARM Limited

Ядро ARM имеет 4 Гбайт последовательной памяти с адресов 0x00000000 до 0xFFFFFFFF.

Различные типы памяти могут быть расположены по эти адресам. Обычно микроконтроллер имеет постоянную память, из которой можно только читать (ПЗУ) и оперативную память, из которой можно читать и в которую можно писать (ОЗУ).

Также часть адресов этой памяти отведены под регистры управления и регистры периферии.

=== Память ОЗУ в микроконтроллере CortexM4

Микроконтроллер на ядре Cortex M4 выполнен по Гарвардской архитектуре, память здесь разделена на три типа:

. ПЗУ (FLASH память в которой храниться программа)

. ОЗУ память для хранения временных данных (туда же можно по необходимости переместить программу и выполнить её из ОЗУ), память в которой находятся регистры отвечающие за настройку и работу с периферией

. Память для хранения постоянных данных ЕЕPROM.

Адресное пространство памяти программы (ПЗУ) находится по адресам 0x00000000 по 0x1FFFFFFF.

Адресное пространство ОЗУ находится по адресам 0x20000000 по 0x3FFFFFFF.

Адресное пространство для регистров периферии находится по адресам с 0x40000000 по 0x5FFFFFFF.

Памяти EEPROM микропроцессора Stm32F411RE не содержит.
Более подробно вы можете изучить адресное пространство микропроцессора в спецификации на микропроцессор.

=== Память для расположения данных

Данные в памяти могут быть расположены 3 различными способами:

Авто(локальные) переменные, которые являются локальными в функции располагаются в регистрах или в стеке.

Глобальные переменные или статические переменные. В этом случае они инициализируются единожды.

Динамически размещаемые данные. Данные создаваемые на Куче(Heap)

Память под функции(команды)
Для расположения функций используется та же самая память с границами от 0x00000000 - 0xFFFFFFFF.

По умолчанию весь код будет лежать в сегменте .text, который расположен в readonly памяти (обычно в ROM), но можно разместить функции и в ОЗУ.

== Указатели

Данные могут находится в ОЗУ или ПЗУ. Каждой переменной содержащей данные соответствует некоторый адрес памяти. К переменной можно обратиться непосредственно обращаясь к самой переменной, тогда мы можем напрямую писать или читать значение с адреса переменной, либо можно обратиться косвенно, через указатель или ссылку.

Указатели представлены на (рисунок <<Pic1>>)

.Указатели
[#Pic1]
image::Рисунок1.png[]

Указатели представляют собой объекты, значением которых служат адреса других объектов (переменных, констант, указателей) или функций.

Указатели широко используются как в C, так и в C++ для трех основных целей:

. для выделения новых объектов в куче;
. передача функций другим функциям;
. для итерации элементов в массивах или других структурах данных.

=== Операции над указателями

Указатели можно складывать, вычитать, сравнивать. Но указатели должны быть одного типа.

Над указателями можно выполнять арифметические операции сложения, инкремента (увеличения на 1), вычитания, декремента (уменьшения на 1) и операции сравнения (>, >=, <, <=, ==, !=). При выполнении арифметических операций с указателями автоматически учитывается размер данных, на которые он указывает.

Указатели можно сравнивать, причём не, только на равенство или неравенство, ведь адреса могут быть меньше или больше относительно друг друга.

Чтобы изменить значение в любой ячейке памяти, нужно использовать указатель. Пример:

* Создадим переменную и получим её адрес:

[.source, cpp]
----
#include <iostream>
int num = 10;
int* prt = & num; //Указатель на переменную num
----

* Изменим значение по этому адресу:

[.source, cpp]
----
#include <iostream>
*ptr = 20; //Изменим значение num на 20
----

=== Указатель типа int

Прибавляя к указателю число, это число не просто добавляется к адресу, а увеличивается на размер того типа данных, на который указывает указатель (потому что 1 + 4 = 5).

Допустим, указатель типа int, который указывает на адрес 1 и к этому адресу прибавляет 1, то указатель будет указывать на адрес 5.

Так как , прибавление числа к указателю означает прибавление этого числа в единицах размера типа данных. Для int это 4 байта, поэтому прибавление 1 к указателю типа int сдвигает его на 4 байта вперёд.


=== Указатель типа double

указатель типа double, который указывает на адрес 1 и к этому адресу прибавляет 1, то указатель будет указывать на адрес 9 (потому что 1 + 8 = 9).

Тип double занимает 8 байт, и когда прибавляется 1 к указателю типа double, адрес увеличивается на 8 байт, так как это размер одного значения типа double.

=== Указатель типа  std::uint32_t

Если указатель типа std::uint32_t указывает на адрес 1, он захватит 4 байта (32 бита) подряд: 10, 20, 30 и 40.

[.source, cpp]
----
std::uint32_t* ptr = reinterpret_cast<std::uint32_t*>(1);
auto b = *ptr;
----

Чаще всего используется little-endian порядок байт, где младший байт (число 10) хранится по младшему адресу (адрес 1), а старшие байты по старшим адресам.
На системах с порядком байт little-endian эти байты образуют число: 673720842.
Значение переменной b после разыменовывания равно 673720842.

=== Указатель типа  std::uint16_t

Если указатель типа std::uint16_t указывает на адрес 1, он прочитает только 2 байта: 10 и 20. Эти байты дадут число 5130.

[.source, cpp]
----
std::uint16_t* ptr = reinterpret_cast<std::uint16_t*>(1);
auto b = *ptr;
----

== Регистр

=== Что такое регистр?

Регистр — это маленькая и очень быстрая ячейка памяти внутри процессора, которая хранит данные, необходимые для текущих вычислений. Процессор использует регистры для выполнения операций быстрее, чем при обращении к оперативной памяти.

Существуют регистры общего назначения и специальные регистры. Регистры общего назначения расположены внутри ядра микроконтроллера(сверхбыстрая память).

Регистры общего назначения - это сверхбыстрая память внутри процессора, предназначенная для хранения адресов и промежуточных результатов вычислений (регистр общего назначения/регистр данных) или данных, необходимых для работы самого процессора.

Регистры специального назначения расположены в ОЗУ микроконтроллера и используются для управления процессором и периферийными устройствами.

Каждый регистр в архитектуре ARM представляет собой ресурс памяти и имеет длину в 32 бита, где каждый бит можно представить в виде выключателя с помощью которого осуществляется управление тем или иным параметром микроконтроллера.

=== Как поменять значение регистра?

В C++, регистры могут меняться косвенно через переменные. Компилятор сам решает, какие значения хранить в регистрах. Например:

[.source, cpp]
----
int a = 10;   // Переменная a может быть помещена в регистр
a = 20;      // Значение a изменяется, и, возможно, будет записано в регистр
----

== Что такое дизъюнкция и конъюнкция?

Дизъюнкция (логическое "ИЛИ", OR): операция, которая возвращает 1, если хотя бы один из операндов равен 1.
Пример: 0 | 1 = 1

Конъюнкция (логическое "И", AND): операция, которая возвращает 1, только если оба операнда равны 1.
Пример: 1 & 1 = 1

== Как сбросить бит?

Чтобы сбросить конкретный бит (сделать его равным 0), можно использовать конъюнкцию с маской, где нужный бит - 0, а все остальные - 1. Пример:

[.source, cpp]
----
x = x & ~(1 << N);  // сбросить N-й бит
----

Здесь 1 << N сдвигает единицу на позицию N, а затем ~ инвертирует биты, чтобы сбросить нужный бит на 0.

== Тип переменной b

[.source, cpp]
----
auto b = "c";
----
Переменная b будет типа const char*, что означает, что она указывает на строку, которую нельзя изменить. Это происходит, потому что строка в двойных кавычках ("c") воспринимается как массив символов, и компилятор автоматически превращает её в указатель на первый символ этого массива.

== Тип переменной b1

[.source, cpp]
----
auto b1 = 'c';
----

Переменная b1 будет типа char, потому что символ в одинарных кавычках ('c') обозначает один единственный символ.

== Перевод символа 'A' в число  

[.source, cpp]
----
char a = 'A';  
----

Символ 'A' будет преобразован в число, которое соответствует его ASCII-коду. В кодировке ASCII символ 'A' равен 65.

== Заключение

В данной работе были изучены типы данных их размеры, явное и неявное преобразования. Также ознакомлены с памятью микроконтроллера CortexM4 и памятью для расположения данных. Были рассмотрены указатели, регистры, дизъюнкция и конъюнкция. Разобраны различные примеры.