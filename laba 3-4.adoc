= Отчет по лабораторной работе №3-4
Выполнила студентка группы КЭ-413, Кузнецова А.С.
:imagesdir: Pic
:toc:
:toc-title: Оглавление
:toclevels: 2
:figure-caption: Рисунок
:table-caption: Таблица

== Указатели 

Указатели — это переменные, которые хранят адреса других переменных в памяти. Они играют важную роль в языке C++ и позволяют работать с памятью напрямую, передавать большие данные в функции без их копирования и создавать динамические структуры данных, такие как списки или деревья. Важно уметь правильно пользоваться указателями, поскольку ошибки с указателями могут привести к сбоям программы и трудноуловимым ошибкам.

=== Включение светодиодов с помощью указателей

Ниже рассмотрен код, с помощью которого светодиоды зажигаются и выключаются в порядке "ёлочки".

Код поочередно включает и выключает четыре светодиода, управляя битами портов GPIO микроконтроллера с помощью битовых масок.

Включение светодиодов: последовательно устанавливает биты в регистрах GPIOA и GPIOC, включая каждый светодиод (LED1–LED4) с паузой (delay).
Выключение светодиодов: последовательно сбрасывает те же биты, выключая светодиоды в том же порядке, с паузой между действиями.
Этот процесс выполняется в бесконечном цикле.

[source, cpp]
----
// Битовые маски
const std::uint32_t maskBit5 = (1U << 5U);
const std::uint32_t maskBit8 = (1U << 8U);
const std::uint32_t maskBit9 = (1U << 9U);

// Указание адресов портов
std::uint32_t* const prtGpiocOdr = reinterpret_cast<uint32_t*>(0x40020814U); // Порт GPIOC
std::uint32_t* const prtGpioaOdr = reinterpret_cast<uint32_t*>(0x40020014U); // Порт GPIOA

for(;;)
{
    // Включение светодиодов
    *prtGpioaOdr |= maskBit5; // Светодиод LED1
    delay(1000000);

    *prtGpiocOdr |= maskBit9; // Светодиод LED2
    delay(1000000);

    *prtGpiocOdr |= maskBit8; // Светодиод LED3
    delay(1000000);

    *prtGpiocOdr |= maskBit5; // Светодиод LED4
    delay(1000000);

    // Выключение светодиодов
    *prtGpioaOdr &= ~maskBit5; // Светодиод LED1
    delay(1000000);

    *prtGpiocOdr &= ~maskBit9; // Светодиод LED2
    delay(1000000);

    *prtGpiocOdr &= ~maskBit8; // Светодиод LED3
    delay(1000000);

    *prtGpiocOdr &= ~maskBit5; // Светодиод LED4
    delay(1000000);

    return 1;
}
----

Хоть данный код и выполняет задачу, он не является универсальным, по нескольким причинам:

* Жестко заданы адреса регистров: Привязка к конкретным адресам GPIOA и GPIOC делает код зависимым от модели микроконтроллера.

* Фиксированные маски битов: Маски для конкретных пинов (5, 8, 9) привязаны к определенным светодиодам. Изменение подключений потребует переписывания кода.

* Нет настройки портов: Код не настраивает порты на вывод; он предполагает, что они уже сконфигурированы.

Далее рассмотрим более гибкую реализацию кода.

== Класс

Класс - это пользовательский тип данных, который служит для объединения данных и методов, работающих с этими данными, в одной структуре. Класс определяет шаблон или "чертеж" для создания объектов, которые являются экземплярами этого класса.
Ниже рассмотрим реализацию кода с помощью класса.

=== Включение светодиодов с помощью класса

[source, cpp]
----
// Создание виртуального класса
class ILed
{
    virtual void Light() = 0;
    virtual void Off() = 0;
    virtual void Toggle() = 0;
};

// Создание класса Led
class Led : public ILed
{
public:
    Led(std::uint32_t registerAddres, std::uint32_t pinNumber) : 
    registerAddr(registerAddres), pinNum(pinNumber) // Конструктор
    {
    }
    void Light() override // Функция включения светодиода
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) |= (1 << pinNum);
    }
    void Off() override // Функция выключения светодиода
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) &= ~(1 << pinNum);
    }
    void Toggle() override // Функция изменения состояния светодиода на противоположное
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) ^= (1 << pinNum);
    }
private:
    std::uint32_t registerAddr; // Адрес указываемого регистра (порта)
    std::uint32_t pinNum; // Номер указываемого номера бита
};
----

Данный код создает интерфейс ILed с методами для управления светодиодом (Light, Off, Toggle) и класс Led, который реализует этот интерфейс.

Класс Led управляет светодиодом, выполняя операции побитового сдвига для работы с конкретным пином регистра:

* Light() — включает светодиод, устанавливая бит.
* Off() — выключает светодиод, сбрасывая бит.
* Toggle() — переключает состояние светодиода на противоположное, инвертируя бит.

Класс позволяет работать со светодиодами, подключенными к заданным портам микроконтроллера.

Также этот класс можно использовать для решения той же задачи — управления включением и выключением светодиодов в нужной последовательности.

Укажем все светодиоды в виде массива для удобства

Рассмотрим реализацию кода "зажигание" светодиодов "елочкой":

[source, cpp]
----
// Битовые маски
constexpr std::uint32_t maskBit5 = (1U << 5U);
constexpr std::uint32_t maskBit8 = (1U << 8U);
constexpr std::uint32_t maskBit9 = (1U << 9U);
// Указание портов
constexpr std::uint32_t gpiocOdrRegAddres = 0x40020814U;
constexpr std::uint32_t gpioaOdrRegAddres = 0x40020014U;
// Указатели
auto const gpioaOdrPtr = reinterpret_cast<std::uint32_t*>(gpioaOdrRegAddres);
auto const gpiocOdrPtr = reinterpret_cast<std::uint32_t*>(gpiocOdrRegAddres);

// Указание элементам массива (светодиодам) порта и бита
Led led1(gpioaOdrRegAddres, 5);
Led led2(gpiocOdrRegAddres, 9);
Led led3(gpiocOdrRegAddres, 8);
Led led4(gpiocOdrRegAddres, 5);

// Создание массива светодиодов
std::array<Led*, 4> leds = {
    &led1,
    &led2,
    &led3,
    &led4};

for(;;)
{
    for(auto it: leds)
    {
        it->Toggle(); // Включение/выключение светодиода
        delay(1000000);
    }
    
    return 1;
}
----

Этот код управляет четырьмя светодиодами, создавая массив объектов типа Led. Для каждого светодиода указаны адрес порта и номер пина. В бесконечном цикле код последовательно включает и выключает светодиоды, вызывая метод Toggle(), с задержкой между изменениями состояния каждого светодиода.

== Вывод

Был реализован код, который гораздо простой и гибкий. Код был сокращен до всего лишь двух строк, выполняющих ту же самую задачу.

== Реализация других режимов включения светодиодов

В ходе лабораторной работы были также рассмотрены другие варианты включения светодиодов: *"елочкой" (уже разобран), все одновременно и в шахматном порядке.*

Таким образом, возникает еще одна задача: помимо указания порта и бита светодиода необходимо также указывать режим их работы.

Далее приведена UML-диаграмма, показывающая обновленную структуру программы.

.UML-диаграмма
image::Picture1.jpg[]

На диаграмме показано, что функции для включения, выключения и переключения состояния светодиодов (Light, Off, Toggle) реализованы через отдельный класс (интерфейс). Это соответствует принципу Single Responsibility, так как каждая функция выполняет свою задачу. Режимы работы светодиодов имеют два метода: обновление (Update()) и установление (Init()), которые реализованы в отдельных классах для каждого режима.

=== Зажигание светодиодов в шахматном порядке

В данном задании необходимо зажигать светодиоды в таком порядке: два горят, два не горят и тд.

Далее необходимо создать виртуальный класс, так как каждый из создаваемых режимов состоит из двух основных функций: обновление и установление.

[source, cpp]
----
class IMode
    {
      virtual void Update() = 0; // Обновление режима
      virtual void Init() = 0; // Установление режима
    };
----

Далее можно приступить к реализации класса, включающего светодиоды в шахматном порядке (класс *ChessMode*).

[source, cpp]
----
using tLeds = std::array<ILed*, 4>; // Создание массива указателей на объекты виртуального класса
class ChessMode: public IMode
    {
    public:
      ChessMode(tLeds& ledsArr): leds(ledsArr)
      {
      }
      // Метод обновления режима
      void Update() override
      {
        for(auto it: leds)
        {
          it->Toggle();
        }
      }
      
      // Метод установления режима
      void Init() override
      {
        for(auto it: leds)
        {
          it->Light();
        }
        for(auto i=0; i< leds.size(); ++i)
        {
          if ((i%2)==0) // Условие четности
          {
            leds[i]->Toggle();
          }
        }
      }
    private:
      tLeds& leds;
    };
----

Был создан виртуальный класс IMode для того, чтобы обеспечить общую структуру и интерфейс для различных режимов, каждый из которых будет реализовывать функции обновления и установки, позволяя легко добавлять новые режимы с одинаковым набором методов.

=== Одновременное включение светодиодов

В данном задании необходимо чтобы светодиоды защжигались одновременно и также одно временно выключались.

[source, cpp]
----
class AllMode:public IMode
 {
 public:
    AllMode(tLeds& ledsArr): leds(ledsArr)
    {
        
    }
      void Update() override
      {
        for(auto it: leds)
        {
          it->Toggle();
        }
      }
      
      void Init() override
      {
        for(auto it: leds)
        {
          it->Light();
        }
        
      }
private:
 tLeds& leds;
 };
----

Этот код создаёт класс AllMode, который управляет набором светодиодов. В нем есть два метода:

* Update() — переключает состояние каждого светодиода (включает, если он выключен, и выключает, если он включен).
* Init() — включает все светодиоды.
Класс использует массив светодиодов, переданный при создании объекта.

=== Светодиоды в режиме "елочки"

В задании необходимо реализовать режим работы светодиодов "елочкой", рассмотренный ранее.

[source, cpp]
----
class TreeMode:public IMode
 {
 public:
    TreeMode(tLeds& ledsArr): leds(ledsArr)
    {
        
    }
      void Update() override
      {
         for(auto it: leds)
        {
          it->Light();
        }
        for(auto i=0; i< leds.size(); ++i)
        {
            leds[i]->Toggle();
        }
      }
        void Init() override
      {
        for(auto it: leds)
        {
          it->Light();
        }
        for(auto i=0; i< leds.size(); ++i)
        {
            leds[i]->Toggle();
        }
      }
    private:
      tLeds& leds;
    };
----

Этот код создает класс TreeMode, который управляет светодиодами. В нем два метода:

* Update() — включает все светодиоды и затем меняет их состояние (включает, если они выключены, и выключает, если они включены).
* Init() — тоже включает все светодиоды и меняет их состояние.
Класс работает с массивом светодиодов, который передается при его создании

== Заключение

В данной лабораторной работе были рассмотрены различные реализации программ, с помощью классов. Можно сделать вывод, что программа реализованная с помощью классов, является более ясной и простой для редактирования.